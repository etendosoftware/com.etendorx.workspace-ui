pipeline {

  environment { // MARK: Environment Variables
    NPM_TOKEN            = credentials('npmjs-access-token')
    EMAIL_ADDRESS        = credentials('email_builds')

    OWNER_REPOSITORY     = "etendosoftware"
    GITHUB_URL           = "https://github.com"
    GITHUB_SSH_URL       = "git@github.com:etendosoftware"

    SUCCESS              = "SUCCESS"
    FAILED               = "FAILED"
    UNSTABLE             = "UNSTABLE"

    COMMIT_INPROGRESS_STATUS = "pending"
    COMMIT_SUCCESS_STATUS    = "success"
    COMMIT_FAILED_STATUS     = "failure"

    CONTEXT_BUILD = "New UI Tests"

    ACCESS_TOKEN = credentials('access_token_github')

    NODE_VERSION = "18"

    REPOSITORY_NAME = "com.etendorx.workspace-ui"
  }

  agent { // MARK: Agent
    kubernetes {
      inheritFrom 'jenkins-node-app'
      defaultContainer 'jnlp'
      yaml """
apiVersion: v1
kind: Pod
metadata:
  name: jenkins-node-app
  namespace: jenkins2025
  labels:
    app.kubernetes.io/name: jenkins-node-app
spec:
  volumes:
    - name: rsa-keys
      configMap:
        name: rsa-keys
        defaultMode: 384
  containers:
    - name: compiler
      image: etendo/compiler_jenkins:1.0.7-jdk.17.0.13
      ports:
        - name: ssh
          containerPort: 22
          protocol: TCP
        - name: visualvm
          containerPort: 8000
          protocol: TCP
      resources:
        limits:
          cpu: 4096m
          memory: 7000Mi
        requests:
          cpu: 2048m
          memory: 5000Mi
      volumeMounts:
        - name: rsa-keys
          mountPath: /root/.ssh/
      securityContext:
        readOnlyRootFilesystem: false
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      imagePullPolicy: IfNotPresent
  restartPolicy: Always
  terminationGracePeriodSeconds: 30
  dnsPolicy: ClusterFirst
  serviceAccountName: default
  serviceAccount: default
  securityContext: {}
    """
    }
  }

  stages {
    stage('Building Environment') { // MARK: Building Environment
      steps {
        container('compiler') {
          script {

            sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Starting Build\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
            try {
              withCredentials([sshUserPrivateKey(credentialsId: 'my-credentials', keyFileVariable: 'keyfile')]) {
                sh "GIT_SSH_COMMAND=\"ssh -i ${keyfile} -o \"UserKnownHostsFile=/dev/null\" -o \"StrictHostKeyChecking=no\"\" git clone ${GITHUB_SSH_URL}/${REPOSITORY_NAME}.git"
              }
              
              echo "-------------------------- Building Environment --------------------------"
              sh """
                curl -sL https://deb.nodesource.com/setup_${NODE_VERSION}.x | bash -
                apt-get install -y nodejs
                npm install -g pnpm
                npm config set registry \"https://registry.npmjs.org/\"
                npm config set //registry.npmjs.org/:_authToken ${NPM_TOKEN}
              """

              echo "-------------------------- Checking out the repository to GIT_COMMIT --------------------------"
              sh """
                cd ${REPOSITORY_NAME}
                git checkout ${GIT_COMMIT}
              """

              echo "-------------------------- Installing Dependencies --------------------------"
              sh """
                cd ${REPOSITORY_NAME}
                pnpm install
                pnpm add -D -w istanbul-lib-coverage istanbul-lib-report istanbul-reports
              """
              echo "-------------------------- Building Project --------------------------"
              sh """
                cd ${REPOSITORY_NAME}
                pnpm build
              """
              echo "-------------------------- Build Successful --------------------------"
              
              echo "-------------------------- Getting Commit Information --------------------------"
              def rootDir = pwd()
              def infoCommit = load "${rootDir}/pipelines/utils/infoCommits.groovy"
              env.URL_ORG_GITHUB = "${GITHUB_URL}/${OWNER_REPOSITORY}"
              def commitInfoTemplate = infoCommit.generateCommitInfo(env.URL_ORG_GITHUB, null, REPOSITORY_NAME, true, REPOSITORY_NAME)
              env.COMMIT_INFO_TEMPLATE = "${commitInfoTemplate}"
              echo "${env.COMMIT_INFO_TEMPLATE}"

              currentBuild.result = SUCCESS
            } catch (Exception e) {
              env.MAIL_SUBJECT = "Environment Building Failed"
              env.ERROR_MESSAGE = "Environment Building Failed"
              echo "Exception occurred: " + e.toString()
              echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
              currentBuild.result = FAILED
              error(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }

    stage('Running Tests') { // MARK: Running Tests
      when {
        expression {
          currentBuild.result == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running Tests\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
              env.STATUSTEST = "1"
              echo "-------------------------- Running Tests --------------------------"
              sh """
                cd ${REPOSITORY_NAME}
                pnpm test:mainui:coverage
                pnpm test:api-client:coverage
                pnpm test:component-library:coverage
              """
              sh """
                cd ${REPOSITORY_NAME}
                node pipelines/utils/merge-coverage.cjs
              """
              echo "-------------------------- Tests Succesful --------------------------"
              currentBuild.result = SUCCESS
            } catch (Exception e) {
              env.ERROR_MESSAGE = "Failed Tests"
              echo "Exception occurred: " + e.toString()
              echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
              currentBuild.result = UNSTABLE
              unstable(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }

    stage('Check data-testid and formatting') { // MARK: Check added data-testid attributes and formatting
      when {
        expression {
          currentBuild.result == SUCCESS
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Checking data-testid and formatting\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
              echo "-------------------------- Checking data-testid and formatting --------------------------"
              // Apply codemod and format; if this produces any git changes, mark UNSTABLE
              def shellScript = '''#!/usr/bin/env bash
set -e
cd ''' + env.REPOSITORY_NAME + '''
# Apply data-testid codemod (writes files)
pnpm run apply:data-testid || echo "‚ùå Codemod application failed, continuing..."

# Run formatter to restore project style
pnpm run format:fix || echo "‚ùå Formatting failed, continuing..."

# If there are any changes in git working tree, exit with code 2 to indicate UNSTABLE
PORCELAIN=$(git status --porcelain)

# List of paths to ignore from the check. Edit this list to add/remove omitted entries.
OMIT_PATTERNS=(
  "package.json"
  "pnpm-lock.yaml"
  "coverage-merged/"
)

# Build a regex alternation like: package.json|pnpm-lock.yaml|coverage-merged/
OMIT_REGEX=$(printf "%s|" "${OMIT_PATTERNS[@]}" | sed 's/|$//')

# Filter out allowed/expected changes (lockfiles, package manifests, coverage outputs)
# Note: escape $ so Groovy doesn't attempt to interpolate the shell variables inside the Jenkinsfile string
FILTERED=$(printf "%s\n" "$PORCELAIN" | grep -Ev "(^[[:space:]]*[AM][[:space:]]+(${OMIT_REGEX})$|^[[:space:]]*\\?\\?[[:space:]]+(${OMIT_REGEX}))" || true)
if [ -n "$FILTERED" ]; then
  echo "üö® Uncommitted changes detected after applying codemod and formatting (excluding: ${OMIT_PATTERNS[*]}):"
  printf "%s\n" "$FILTERED"
  exit 2
fi
exit 0
'''

              // Run the prepared script using bash so bash-specific features (arrays, pipefail) work.
              // Use a heredoc to pass the script contents to bash to avoid /bin/sh (dash) errors.
              def status = sh(script: "bash -e -o pipefail <<'BASH'\n${shellScript}\nBASH", returnStatus: true)

              if (status == 0) {
                echo "-------------------------- data-testid check & format are clean --------------------------"
                currentBuild.result = SUCCESS
              } else if (status == 2) {
                env.ERROR_MESSAGE = "Data-testid check produced uncommitted changes"
                echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                currentBuild.result = UNSTABLE
                unstable(env.ERROR_MESSAGE)
              } else {
                env.ERROR_MESSAGE = "Data-testid check failed with status ${status}"
                echo "Exception occurred: status ${status}"
                echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                currentBuild.result = FAILED
                error(env.ERROR_MESSAGE)
              }
            } catch (Exception e) {
              env.ERROR_MESSAGE = "Data-testid and/or format check failed"
              echo "Exception occurred: " + e.toString()
              echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
              currentBuild.result = FAILED
              error(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }

    stage('UI/Storybook Tests') { // MARK: STORYBOOK
        when {
            expression {
                false
            }
        }
        steps {
            container('compiler') {
                timeout(time: 25, unit: 'MINUTES') {
                    sh """
                    cd ${REPOSITORY_NAME}

                    pnpm run storybook -- --host 127.0.0.1 --port 6006 --quiet &
                    SB_PID=\$!
                    trap "kill \$SB_PID || true" EXIT

                    # 2) (Opcional) Instalar browsers de Playwright si tu imagen no los trae
                    pnpm dlx playwright install --with-deps chromium

                    # 3) Esperar a que el server est√© listo
                    pnpm dlx wait-on --timeout 180000 http://127.0.0.1:6006/index.json

                    # 4) Ejecutar el runner desde el paquete de storybook
                    cd packages/storybook
                    pnpm test-storybook --ci --url http://127.0.0.1:6006 --maxWorkers=2 
                    """
                }
            }
        }
    }

    stage('Run Sonarqube Analysis') { // MARK: Run Sonarqube Analysis
      when {
        expression {
          currentBuild.result == SUCCESS
        }
      }
      environment {
          scannerHome = tool 'etendo-sonar-scanner';
          JAVA_HOME = '/usr/lib/jvm/jdk-17.0.13'
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Running SonarQube Analysis\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
              echo "-------------------------- Running SonarQube Analysis --------------------------"
              withSonarQubeEnv(credentialsId: 'sonar-token-access', installationName: 'SonarQubeServer') {
                sh """
                  cd ${REPOSITORY_NAME}
                  ${scannerHome}/bin/sonar-scanner \
                  -Dsonar.branch.name=${GIT_BRANCH} \
                  -Dsonar.projectVersion=${GIT_COMMIT} \
                  -Dsonar.scm.revision=${GIT_COMMIT} \
                  -Dsonar.javascript.lcov.reportPaths=coverage-merged/lcov.info
                """
              }
              echo "-------------------------- SonarQube Analysis Succesful --------------------------"
            } catch (Exception e) {
              env.MAIL_SUBJECT = "Failed SonarQube Analysis"
              env.ERROR_MESSAGE = "Failed SonarQube Analysis"
              echo "Exception occurred: " + e.toString()
              echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
              currentBuild.result = FAILED
              unstable(env.ERROR_MESSAGE)
            }
          }
        }
      }
    }
    stage('Compare Coverage with Main Branch') { // MARK: Coverage Comparison
      when {
        expression {
          currentBuild.result == SUCCESS && GIT_BRANCH != 'main'
        }
      }
      steps {
        container('compiler') {
          script {
            try {
              sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_INPROGRESS_STATUS} \"Comparing Coverage\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
              echo "-------------------------- Comparing Coverage with Main Branch --------------------------"

              def sonarPropertiesFile = "${REPOSITORY_NAME}/sonar-project.properties"
              def sonarProjectKey = sh(script: "grep 'sonar.projectKey' ${sonarPropertiesFile} | cut -d '=' -f2", returnStdout: true).trim()
              echo "SonarQube Project Key: ${sonarProjectKey}"
              def branchCurrent = URLEncoder.encode(GIT_BRANCH, 'UTF-8') 
              def projectUrl = "${SONAR_SERVER}/dashboard?id=${sonarProjectKey}&branch=${branchCurrent}"
              echo "Project URL: ${projectUrl}"
              def branchMain = "main"

              def rootDir = pwd()
              def sonarUtils = load "${rootDir}/pipelines/utils/sonarUtils.groovy"

              def checkCommitCurrent = GIT_BRANCH.startsWith('feature/') || GIT_BRANCH.startsWith('hotfix/') || GIT_BRANCH.startsWith('epic/')
              echo "Check commit for current branch (${GIT_BRANCH}): ${checkCommitCurrent}"
              def coverageCurrent = sonarUtils.getCoverageWithRetry(
                GIT_BRANCH,
                checkCommitCurrent,
                sonarProjectKey,
                SONAR_TOKEN,
                SONAR_SERVER,
                GIT_COMMIT
              )
              def coverageMain = sonarUtils.getCoverageWithRetry(
                branchMain,
                false,
                sonarProjectKey,
                SONAR_TOKEN,
                SONAR_SERVER,
                null
              )

              echo "Current branch coverage: ${coverageCurrent}%"
              echo "Main branch coverage: ${coverageMain}%"

              if (coverageCurrent < coverageMain) {
                env.ERROR_MESSAGE = "Coverage (${coverageCurrent}%) is lower than main branch (${coverageMain}%)"
                echo "-------------------------- ${env.ERROR_MESSAGE} --------------------------"
                currentBuild.result = FAILED
                error(env.ERROR_MESSAGE)
              } else {
                echo "-------------------------- Coverage is OK --------------------------"
                currentBuild.result = SUCCESS
              }
            } catch (Exception e) {
              env.MAIL_SUBJECT = "Coverage comparison failed"
              echo "Exception occurred: " + e.toString()
              echo "-------------------------- ${env.MAIL_SUBJECT} --------------------------"
              currentBuild.result = FAILED
              error(env.MAIL_SUBJECT)
            }
          }
        }
      }
    }
  }
    
  post { // MARK: Post Actions
    success {
      script {
        sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_SUCCESS_STATUS} \"Successful Tests\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
      }
    }

    unstable {
      script {
        sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_FAILED_STATUS} \"${env.ERROR_MESSAGE}\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
      }
      script {
        // Build the email body dynamically with a more descriptive message.
        def bodyHtml = """
          <html>
            <head>
                <style>
                    body { font-family: 'Arial', sans-serif; }
                    .header { font-size: 18px; font-weight: bold; color: #b33; }
                    .section { margin-top: 12px; }
                    pre { background:#f6f6f6; padding:10px; border-radius:4px; }
                </style>
            </head>
            <body>
              <p><em>${new Date()}</em></p>
              <hr />

              <h2 class=\"header\">üö® BUILD UNSTABLE: Attention required</h2>

              ${env.COMMIT_INFO_TEMPLATE}

              <div class=\"section\">
                <strong>Summary:</strong>
                <p>The CI ran automated code checks and one or more quick-fix codemods (data-testid + formatting). The pipeline attempted to apply them automatically; however, there are local changes that were not committed in the PR, so the build is marked <strong>UNSTABLE</strong> to request author action.</p>
              </div>

              <div class=\"section\">
                <strong>Cause:</strong>
                <p>${env.ERROR_MESSAGE ?: 'Checks reported issues (see build logs).'}</p>
              </div>

        """

        // If the error mentions the data-testid check include explicit repair steps and docs link
        if (env.ERROR_MESSAGE?.toString()?.toLowerCase()?.contains('data-testid')) {
          bodyHtml += """

            <div class=\"section\">
              <strong>What happened:</strong>
              <p>The repository enforces a deterministic <code>data-testid</code> attribute across React components. An automated transformer adds these attributes; if your branch is missing them, the pipeline will attempt to add them and then require you to commit the changes.</p>
            </div>

            <div class=\"section\">
              <strong>How to fix locally:</strong>
              <pre>
# 1) Run the dry-check (shows what would change):
pnpm run check:data-testid

# 2) Apply the codemod and format the repo:
pnpm run apply:data-testid
pnpm run format:fix

# 3) Review and commit the changes:
git add -A
git commit -m "Apply add-data-testid codemod and format"
              </pre>
            </div>

            <div class=\"section\">
              <strong>Documentation:</strong>
              <p>See the project guide: <a href=\"${GITHUB_URL}/${OWNER_REPOSITORY}/${REPOSITORY_NAME}/blob/${GIT_BRANCH}/docs/data-testid-check.md\">docs/data-testid-check.md</a></p>
            </div>
          """
        }

        bodyHtml += """

              <div class=\"section\">
                <strong>Notes:</strong>
                <ul>
                  <li>The build is UNSTABLE to avoid blocking merges but still signal that work is needed.</li>
                  <li>If you prefer, you can run <code>pnpm run apply:data-testid:commit</code> to apply and commit automatically (use with caution).</li>
                </ul>
              </div>
              <p>To more information on the failing run visit: ${env.BUILD_URL}</p>
              <p class=\"footer\"><em>Best regards,<br>#EtendoBot ü§ñ</em></p>
              <hr />
            </body>
          </html>
        """

        mail to: EMAIL_ADDRESS,
              subject: "üö® Build UNSTABLE: '${REPOSITORY_NAME}' - ${currentBuild.fullDisplayName}",
              mimeType: "text/html",
              body: bodyHtml
      }
    }
    
    failure {
      script {
        sh "./pipelines/utils/repo-update-scripts/build-update-github.sh ${REPOSITORY_NAME} ${COMMIT_FAILED_STATUS} \"Build Failed\" ${ACCESS_TOKEN} ${GIT_COMMIT} ${BUILD_URL} \"${CONTEXT_BUILD}\""
      }
      mail to: EMAIL_ADDRESS,
      subject: "üö´ ${env.MAIL_SUBJECT} in '${REPOSITORY_NAME}' - ${currentBuild.fullDisplayName}",
      mimeType: "text/html",
      body:  """
        <html>
          <head>
              <style>
                  body { font-family: 'Arial', sans-serif; }
                  .header { font-size: 16px; font-weight: bold; color: #333; }
              </style>
          </head>
          <body>
            <p><em>${new Date()}</em></p>
            <p>__________________________________________________________</p>

            <h2 class="header">üö´ BUILD FAILED üö´</h2>

            ${env.COMMIT_INFO_TEMPLATE}

            <p><strong>${env.ERROR_MESSAGE}.</strong><br>To more information on the failing run visit: ${env.BUILD_URL}</p>

            <p class="footer"><em>Best regards,<br>#EtendoBot ü§ñ</em></p>
            <p>__________________________________________________________</p>
          </body>
        </html>
      """
    }
  }
}